/*
 * Copyright (c) 2024 Huawei Technologies Co., Ltd.
 * This file is a part of the CANN Open Software.
 * Licensed under CANN Open Software License Agreement Version 1.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */
#include "collectives.cce"

template<typename T>
__attribute__((always_inline)) inline __aicore__ void LcalAllReduce2npuBigDataWriteOrigin
    (__gm__ T* buff[8], __gm__ T *input, __gm__ T *output, int64_t blockNumPerGroup, uint32_t rank, uint32_t rankSize,
     uint64_t len, int64_t magic, __ubuf__ int64_t* ctrlFlagsUB, __ubuf__ int64_t* ctrlFlagsUB1,
     __ubuf__ int64_t* ctrlFlagsUB2, __ubuf__ T* inputUB[2], int64_t dataOffsetNum, int64_t flagOffset1st,
     int64_t flagOffset2nd, int64_t x, int64_t corePerRank, int64_t coreSegmentedIdx, int op)
{
    const int64_t dataBlockAllNum = CeilDiv(len * sizeof(T), MEM_DMA_UNIT_BYTE);
    const int64_t singleCoreDataBlockNum = dataBlockAllNum / blockNumPerGroup;
    const int64_t singleCoreDataNum = singleCoreDataBlockNum * MEM_DMA_UNIT_BYTE / sizeof(T);
    const int64_t buffDataDMAOffsetNum = coreSegmentedIdx * singleCoreDataNum;

    int64_t dataSizeRemain = singleCoreDataBlockNum * MEM_DMA_UNIT_BYTE;
    if (coreSegmentedIdx == blockNumPerGroup - 1) {
        dataSizeRemain = (len - singleCoreDataNum * coreSegmentedIdx) * sizeof(T);
    }

    __gm__ T *receiveBuff = (__gm__ T*)((__gm__ int64_t*)buff[x] + dataOffsetNum);
    __gm__ int64_t* ctrlFlagsGM = (__gm__ int64_t*)buff[rank] + flagOffset1st;
    __gm__ int64_t* ctrlFlagsGMX = (__gm__ int64_t*)buff[x] + flagOffset1st;
    if (GetBlockIdx() < blockNumPerGroup) {
        input2BuffRankMagic(
            dataSizeRemain, inputUB[0], receiveBuff, buffDataDMAOffsetNum, input, buffDataDMAOffsetNum,
            ctrlFlagsUB, ctrlFlagsGMX, magic);
        return;
    }
    GM2GMPingPong<T>(dataSizeRemain, inputUB, output, buffDataDMAOffsetNum, input, buffDataDMAOffsetNum);

    *ctrlFlagsUB = 0;
    *ctrlFlagsUB1 = 0;
    int64_t allDataSizeNeed2Add = dataSizeRemain;
    AscendC::PipeBarrier<PIPE_ALL>();
    while (true) {
        if (*ctrlFlagsUB >= CeilDiv(allDataSizeNeed2Add, DMA_SIZE_PER_FLAG)) {
            break;
        }

        CpGM2UB(ctrlFlagsUB1, ctrlFlagsGM, sizeof(int64_t));
        AscendC::PipeBarrier<PIPE_ALL>();

        if ((*ctrlFlagsUB1 >> 10) != (magic >> 10)) {
            continue;
        }
        int64_t preparedDataGroupCount = (*ctrlFlagsUB1 - magic);
        if (preparedDataGroupCount <= 0 || *ctrlFlagsUB >= preparedDataGroupCount) {
            continue;
        }

        dataSizeRemain = (preparedDataGroupCount - *ctrlFlagsUB) * DMA_SIZE_PER_FLAG;
        if (preparedDataGroupCount * DMA_SIZE_PER_FLAG > allDataSizeNeed2Add) {
            dataSizeRemain = allDataSizeNeed2Add - *ctrlFlagsUB * DMA_SIZE_PER_FLAG;
        }
        ProcessDataNew<T>(dataSizeRemain, inputUB, buff[rank], dataOffsetNum,
                       buffDataDMAOffsetNum + (*ctrlFlagsUB) * DMA_SIZE_PER_FLAG / sizeof(T),
                       output, buffDataDMAOffsetNum + (*ctrlFlagsUB) * DMA_SIZE_PER_FLAG / sizeof(T), op);
        AscendC::PipeBarrier<PIPE_ALL>();

        *ctrlFlagsUB = preparedDataGroupCount;
        AscendC::PipeBarrier<PIPE_ALL>();
    }
}

template<typename T>
__attribute__((always_inline)) inline __aicore__ void LcalAllReduce2npuBigDataWrite(ALLREDUCE_ARGS_FUN_16P(T))
{
    DumpLcclLogInfo(dumpAddr, LogId::OVERALL, static_cast<Op>(op));
    DumpLcclLogInfo(dumpAddr, LogId::INIT, static_cast<Op>(op));
    magic *= 1024;
    const int64_t dataOffsetNum = GetLcalBlockNum() * 2 * MEM_DMA_UNIT_INT_NUM;
    int64_t flagOffset1st = MEM_DMA_UNIT_INT_NUM * GetBlockIdx();
    __gm__ T* buff[8] = {
        buff0, buff1, buff2, buff3,
        buff4, buff5, buff6, buff7
    };
    __ubuf__ int64_t* ctrlFlagsUB = (__ubuf__ int64_t*)(0);
    __ubuf__ int64_t* ctrlFlagsUB1 = (__ubuf__ int64_t*)(32);
    __ubuf__ int64_t* ctrlFlagsUB2 = (__ubuf__ int64_t*)(64);
    __ubuf__ T* inputUB[2] = {(__ubuf__ T*)(96), (__ubuf__ T*)(97440)};

    int64_t blockNumPerGroup = GetLcalBlockNum() >> 1;
    int64_t corePerRank = blockNumPerGroup;
    int64_t coreSegmentedIdx = GetBlockIdx() % corePerRank;
    int64_t x = (rank == 0 ? 1 : 0);
    if (GetBlockIdx() >= blockNumPerGroup) {
        flagOffset1st = (GetBlockIdx() - blockNumPerGroup) * MEM_DMA_UNIT_INT_NUM;
    }
    int64_t flagOffset2nd = GetLcalBlockNum() * MEM_DMA_UNIT_INT_NUM + flagOffset1st;

    DumpLcclLogInfo(dumpAddr, LogId::INIT, static_cast<Op>(op));

    DumpLcclLogInfo(dumpAddr, LogId::PROCESS, static_cast<Op>(op));
    int64_t ipcBuffMaxNum = IPC_BUFF_MAX_SIZE / sizeof(T);
    for (int64_t i = 0; i < CeilDiv(len, ipcBuffMaxNum); i++) {
        *ctrlFlagsUB = 0;
        *ctrlFlagsUB1 = 0;
        AscendC::PipeBarrier<PIPE_ALL>();

        int64_t processedNum = i * ipcBuffMaxNum;
        int64_t remainNum = (len - processedNum < ipcBuffMaxNum) ? len - processedNum : ipcBuffMaxNum;

        PostSyncBigDataWriteAcrossCard<T>(ctrlFlagsUB, buff, rank, rankSize, dataOffsetNum, ipcBuffMaxNum, magic, i);
        LcalAllReduce2npuBigDataWriteOrigin<T>(
            buff, input + processedNum, output + processedNum, blockNumPerGroup, rank, rankSize, remainNum, (magic + i) * 1024, ctrlFlagsUB, ctrlFlagsUB1,
            ctrlFlagsUB2, inputUB, dataOffsetNum, flagOffset1st, flagOffset2nd, x, corePerRank, coreSegmentedIdx, op);
        AscendC::PipeBarrier<PIPE_ALL>();
    }
    DumpLcclLogInfo(dumpAddr, LogId::PROCESS, static_cast<Op>(op));
    DumpLcclLogInfo(dumpAddr, LogId::OVERALL, static_cast<Op>(op));
}
